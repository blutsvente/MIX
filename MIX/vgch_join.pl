# -*-* perl -*- -w
#  header for MS-Win! Remove for UNIX ...
#!/bin/sh --
#! -- # -*- perl -*- -w
eval 'exec ${PERL:-`[ ! -d "$HOME/bin/perl" -a -x "$HOME/bin/perl" ] && echo "$HOME/bin/perl" || { [ -x /usr/bin/perl ] && echo /usr/bin/perl || echo /usr/local/bin/perl ; } `} -x -S $0 ${1+"$@"} ;'
if 0; # dynamic perl startup; suppress preceding line in perl

use strict;
use warnings;
use Cwd;
use File::Basename;
use Getopt::Long qw(GetOptions);
use Pod::Text;
# use diagnostics; # -> will be set by -debug option
# use English;       # -> not need this, just consumes performance

# +-----------------------------------------------------------------------+
# |                                                                       |
# |   Copyright Micronas GmbH, Inc. 2005.                                 |
# |     All Rights Reserved.                                              |
# |                                                                       |
# |                                                                       |
# | THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF MICRONAS GMBH          |
# | The copyright notice above does not evidence any actual or intended   |
# | publication of such source code.                                      |
# |                                                                       |
# +-----------------------------------------------------------------------+

# +-----------------------------------------------------------------------+
# | Id           : $Id: vgch_join.pl,v 1.1 2005/10/18 09:35:31 wig Exp $  |
# | Name         : $Name:  $                                              |
# | Description  : $Description:$                                         |
# | Parameters   : -                                                      | 
# | Version      : $Revision: 1.1 $                                      |
# | Mod.Date     : $Date: 2005/10/18 09:35:31 $                           |
# | Author       : $Author: wig $                                      |
# | Phone        : $Phone: +49 89 54845 7275$                             |
# | Fax          : $Fax: $                                                |
# | Email        : $Email: wilfried.gaensheimer@micronas.com$             |
# |                                                                       |
# | Copyright (c)2005 Micronas GmbH. All Rights Reserved.                 |
# | MIX proprietary and confidential information.                         |
# |                                                                       |
# +-----------------------------------------------------------------------+

# +-----------------------------------------------------------------------+
# |                                                                       |
# | Changes:                                                              |
# | $Log: vgch_join.pl,v $
# | Revision 1.1  2005/10/18 09:35:31  wig
# | Merge register sheets from VGCH project.
# |                                                                |
# |                                                                       |
# +-----------------------------------------------------------------------+

# --------------------------------------------------------------------------

#******************************************************************************
# Other required packages
#******************************************************************************

use FindBin;

use lib "$FindBin::Bin/..";
use lib "$FindBin::Bin/../lib/perl";
use lib "$FindBin::Bin";
use lib "$FindBin::Bin/lib/perl";
use lib getcwd() . "/lib/perl";
use lib getcwd() . "/../lib/perl";

use Log::Agent;
use Log::Agent::Priorities qw(:LEVELS);
use Log::Agent::Driver::File;

use Micronas::MixUtils qw( mix_init %EH %OPTVAL mix_getopt_header
	convert_in db2array replace_mac);
use Micronas::MixUtils::IO qw(init_ole open_infile write_sum
	write_outfile);
# use Micronas::MixParser;
# use Micronas::MixIOParser;
# use Micronas::MixI2CParser;
# use Micronas::MixWriter;
# use Micronas::MixReport;


##############################################################################
# Prototypes (generated by "grep ^sub PROG | sed -e 's/$/;/'")
#
# functions in here:
sub fix_sheet ($$);
sub get_sheet ($);
sub get_client ($$);
sub parse_vgch_top ($);
sub replace_macros ($);

#
#******************************************************************************
# Global Variables
#******************************************************************************

$::VERSION = '$Revision: 1.1 $'; # RCS Id
$::VERSION =~ s,\$,,go;

logconfig(
        -driver => Log::Agent::Driver::File->make(
        # -prefix      => $0,
        -showpid       => 0,
        -duperr        => 1,   #Send errors to OUTPUT and ERROR channel ...
        -channels    => {
        # 'error'  => "$0.err",
            'output' => $FindBin::Script . ".out",
            'debug'  => $FindBin::Script . ".dbg",
            },
        )
);

#
# Step 0: Init $0
#
mix_init();               # Presets ....

$EH{'macro'}{'%UNDEF_1%'} = '';

##############################################################################
#
# Step 1: Read arguments, option processing,
#
# parse command line, print banner, print help (if requested),
# set quiet, verbose
#

#
#TODO: Add that to application note
# -dir DIRECTORY            write output data to DIRECTORY (default: cwd())
# -conf key.key.key=value   Overwrite $EH{key}{key}{key} with value
# -listconf                 Print out all available/predefined configurations options
# -sheet SHEET=MATCH        SHEET can be one of "hier", "conn", "vi2c"
# -delta                    Enable delta mode: Print diffs instead of full files.
#                                   Maybe we can set a return value of 1 if no changes occured!
# -strip                    Remove extra worksheets from intermediate output
#                                   Please be catious when using that option.
# -bak                      Shift previous generated output to file.v[hd].bak. When combined
#                                   with -delta you get both .diff, .bak and new files :-)
#

# -top TOP

# Add your options here ....
mix_getopt_header( qw(
    dir=s
    out=s
    conf|config=s@
    sheet=s@
    top=s
    listconf
    delta!
    strip!
    bak!
    init
    import=s@
    report=s@
    ));

if ( $#ARGV < 0 ) { # Need  at least one sheet!!
    logdie("ERROR: No input file specified!\n");
}

##############################################################################
#
# Step 2: Open input files one by one and retrieve the required tables
# Do a first simple conversion from Excel arrays into array of hashes
#

my %sheets = ();

my %xls = ();
my $top = '';
$xls{'top'} = '.*';
$xls{'top_sheet'} = "Sheet1";

$xls{'others'} = 'peri.*'; # Take the default.xls config key
$EH{'default'}{'xls'} = '.*';

# Assume top is defined as option:
if ( $OPTVAL{'top'} ) {
	$top = $OPTVAL{'top'};
	unshift( @ARGV, $top );
} else {
	# Else it has to be the first argument ... (or the first??)
	$top = $ARGV[0];
}

# Put everything on one large array ...
my @all = ();
my $sub_order = '';
my $sub_addr = '';
my $sub_key = '';

#
# open the top file first,
#   then one after next one ...
#
for my $files ( @ARGV ) {
	# Open all files and retrieve sheet(s)
	my $sel = $EH{'default'}{'xls'};
	my $type = 'default';

	
	if ( $files eq $top ) {
		$sel = $xls{'top'};
		$type = 'join';
	}
	my $conn = open_infile( $files,
			$sel, # Set to the appropriate list ....
			$EH{$type}{'req'} . ',hash' );
	#	read in sheets matching default.xls from $files ...

		
	# Convert to hashes ...
	for my $sheetname ( keys %$conn ) {
		my @arrayhash = convert_in ($type, $conn->{$sheetname} );
		$sheets{$files}{$sheetname} = \@arrayhash;
	}

	if ( $files eq $top ) {
		# Find the top sheet -> vgch_top.xls -> Sheet1
		# Parse all addresses from ::client -> ::sub
		( $sub_order, $sub_addr, $sub_key ) = parse_vgch_top( $sheets{$top}{$xls{top_sheet}} );
		# sub_order: hash with numbers ...
		# sub_addr: array with more all infos from top
		# sub_map: hash of arrays: point definitions to matching instances
		next;
	}

	# If the sheets matches a client from the top, print out ...
	for my $s ( keys( %{$sheets{$files}} )) {
		
		my @topclient = get_client( $s, $sub_key );
		if ( scalar( @topclient ) < 1 ) {
			logwarn( "Warning: sheet $s from file $files does not match any client!" );
			push( @all, { '::ign' => '# # # =:=:=:=> Sheet: ' . $s .
				' from file ' . $files . ' does not match any client !!!' } );
			next;
		}

		# @topclient -> convert into client list
		for my $thisclient ( @topclient ) {
			$sub_addr->[$thisclient]{'used'}++; # Increase it ...
		
			my $client	= $sub_addr->[$thisclient];
			my $def 	= $client->{'definition'};
			# if ( defined( $s ) ) {	
			logwarn( "Info: apply sheet $s from file $files to client " .
					$client->{'client'} . '(' . $def . ')' );
			push( @all, { '::ign' => '# # # =:=:=:=> Sheet: ' . $s . ' from file '
				. $files .
				' for definition of ' . $client->{'client'} . '(' . $def . ')' } );
			my $data = fix_sheet( $client, $sheets{$files}{$s} );
			push( @all, @$data );
			# Remove the tmp. data ....

			
			# } 
			# else {
			# 	push( @all, { '::ign' => '# # # =:=:=:=> Sheet: ' . '__MISS__' .
			# 		' from file ' . '__MISS__' . ' for definition of ' . $def } );
			# }
		}
		delete( $sheets{$files}{$s} );
	}
	Micronas::MixUtils::IO::mix_utils_io_del_abook (); # Remove cached data ....
}

##############################################################################
#
# Step 3: Merge the sheets into one,
#    fix some fields (::sub)
#


# fix all others ....

#
# Write back the collected data:
#


=head2 OLD

# Iterate over all clients:
for my $client ( @$sub_addr ) {

# Find filename and sheet for that client
	my $def = $client->{'definition'};
	my $cname = $client->{'client'};
	my ( $f, $s ) = get_sheet( $def );
	# for my $s ( keys %{$sheets{$f}} ) {
	# add the sheet name as comment to ::ign

	if ( defined( $s ) ) {	
		push( @all, { '::ign' => '# # # =:=:=:=> Sheet: ' . $s . ' from file ' . $f .
			' for definition of ' . $cname . '(' . $def . ')' } );
		my $data = fix_sheet( $client, $sheets{$f}{$s} );
		push( @all, @$data );
	} else {
		push( @all, { '::ign' => '# # # =:=:=:=> Sheet: ' . '__MISS__' .
			' from file ' . '__MISS__' . ' for definition of ' . $def } );
	}
}

=cut

# Did we get definitions for all data in top:
for my $k ( keys( %$sub_order ) ) {
	if ( $sub_order->{$k} < 2 ) {
		# Never got it
		logwarn("Warning: did not find registermaster for $k");
	}
}

	
# Convert back to table and print out ...

# Print TOP sheet ->
my $end_table = db2array( $sheets{$top}{$xls{'top_sheet'}}, 'join', '' );
replace_macros( $end_table );
write_outfile( "joined.xls" , "VGCH_TOP", $end_table );

$end_table = db2array( \@all, 'default', '' );
replace_macros( $end_table );


write_outfile( "joined.xls" , "JOIN_VGCH", $end_table );

my $status = ( write_sum() ) ? 1 : 0; # If write_sum returns > 0 -> exit status 1

exit $status;

#
# Inplace replacement of macros %...%
#
sub replace_macros ($) {
	my $dref = shift;
	
	# Duplicate array
	for my $i ( @$dref ) {
		for my $ii ( @$i ) {
			if ( defined ( $ii ) ) {
				$ii = replace_mac( $ii, $EH{'macro'} );
			}
		}
	}
} # End of replace_macros

#
# Sum up hex numbers of adresses ...
#
sub fix_sheet ($$) {
	my $client = shift;
	my $inref = shift;
	
	my $base = hex($client->{'sub'}); # Get it hexadecimal ....
	
	my @outdata = ();
	for my $i ( @$inref ) {
		push( @outdata, { %$i } ); # Make sure data gets >copied<
		my $sub;
		if ( $i->{'::sub'} =~ m/^[0-9a-f]+$/io ) {
			$sub = hex($i->{'::sub'});
		} else {
			$sub = $i->{'::sub'};
		}
		if ( $sub =~ m/^\d+$/o ) {# How to test for digits?
			$sub += $base;
			$outdata[-1]{'::addr'} = sprintf( '%lx', $sub); # How to protect that against
		} else {
			$outdata[-1]{'::addr'} = $sub . " + $base";
		}
	}
	
	return \@outdata;
} # End of fix_sheet

#
# Get a matching sheet name:
#
sub get_sheet ($) {
	my $client = shift;

	$client =~ s/^sci_//;
	$client = lc( $client );	
	for my $f ( keys %sheets ) {
		for my $s ( keys %{$sheets{$f}} ) {
			if ( $s =~ m/$client/i ) {
				logsay( "INFO: found sheet $s in file $f for client $client" );
				return ($f, $s);
			}
			# add the sheet name as comment to ::ign

		}
	}
	logwarn("WARNING: Cannot allocate matching sheet for client $client!");
} # End of get_sheet

#
# Get matching top description for a given sheet name
# Key 
# 
# Input:
#	sheetname
#	hash with "definition"
#
# Output:
#	matching definition array
#
sub get_client ($$) {
	my $sheetname	= shift;
	my $topref		= shift;
	# my $topaddr		= shift;

	for my $k ( keys( %$topref ) ) {
		( my $key = lc($k) ) =~ s/sci_//;
		$key =~ s/_shared//; # for mded_peri_shared ...
		if ( $sheetname =~ m/$key$/i ) {# Match a sheet if the name ends correct!
			return @{$topref->{$k}};
		}
	}
	return ();	
}

	
# ::ign	::client ::definition ::group ::group_id ::grp_awidth ::group_addr
#		::subwidth ::sub ::cpu1_addr ::cpu2_addr ::xls_def
# Ignore	Group Description		Instance Name	Definition	Group	ID in Group	Group Address Width	Client Addr Space [kB]	Group Address [hex]	Physical Interconnect Address width	Physical Interconnect  Address [hex]	CPU1 Address [hex]	CPU2 Address [hex]	Contact	Client Definition Xls - Path

sub parse_vgch_top ($) {
	my $sheet = shift;
	
	# Use array to keep order
	# Additional hash to reference ...
	my @map = ();
	my %map = ();
	my %defmap = ();
	my $n = 0;
	for my $i ( @$sheet ) {
		next if $i->{'::ign'} =~ m/^\s*#/;
		
		# Get client name (primary key!)
		my $client = $i->{'::client'};
		next if $client =~ m/^\W+$/;
		
		$map{$client} = $n;
		$map[$n]{'client'} = $client;
		$map[$n]{'cpu1'} = $i->{'::cpu1_addr'};
		$map[$n]{'cpu2'} = $i->{'::cpu2_addr'};
		$map[$n]{'definition'} = $i->{'::definition'};
		$map[$n]{'sub'} = $i->{'::sub'};
	
		push( @{$defmap{$i->{'::definition'}}}, $n );
				
		$n++;
	}

	
	return \%map, \@map, \%defmap;
} # End of parse_vgch_top
				
#!End