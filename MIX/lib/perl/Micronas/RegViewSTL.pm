###############################################################################
#  RCSId: $Id: RegViewSTL.pm,v 1.1 2005/11/23 13:31:17 lutscher Exp $
###############################################################################
#
#  Revision      : $Revision: 1.1 $                                  
#
#  Related Files :  Reg.pm
#
#  Author(s)     :  Thorsten Lutscher                                      
#  Email         :  thorsten.lutscher@micronas.com                          
#
#  Project       :  MIX                                                 
#
#  Creation Date :  18.11.2005
#
#  Contents      :  Generate STL stimuli file for register testing from Reg 
#                   object
#        
###############################################################################
#                               Copyright
###############################################################################
#
#       Copyright (C) 2005 Micronas GmbH, Munich, Germany 
#
#     All rights reserved. Reproduction in whole or part is prohibited
#          without the written permission of the copyright owner.
#
###############################################################################
#                                History
###############################################################################
#
#  $Log: RegViewSTL.pm,v $
#  Revision 1.1  2005/11/23 13:31:17  lutscher
#  initial release, not yet functional
#
#
###############################################################################

package Micronas::Reg;

#------------------------------------------------------------------------------
# Used packages
#------------------------------------------------------------------------------
use strict;
use Data::Dumper;
use Micronas::MixUtils qw(%EH);
use Micronas::Reg;
use Micronas::RegDomain;
use Micronas::RegReg;
use Micronas::RegField;
use Micronas::MixUtils::RegUtils;

#------------------------------------------------------------------------------
# Private methods (of class Reg)
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# view: STL

# Main entry function of this module;
# input: domain names for which STL files are generated; if omitted, 
# STL file will consider ALL register space domains in the Reg object;
# output: 0 in case of non-recoverable error, 1 otherwise
sub _gen_view_stl {
	my $this = shift;
	my $href;
	my @lexclude_regs;

	# extend class data with data structure needed for code generation
	$this->global(
				  'debug'              => 0,
				  'indent'             => "    ",       # indentation character(s)
				  'pragma_head_start'   => "pragma MIX_STL head begin",
				  'pragma_head_end'     => "pragma MIX_STL head end",
				  'pragma_body_start'   => "pragma MIX_STL body begin",
				  'pragma_body_end'     => "pragma MIX_STL body end",
				  'file_suffix'        => "stl",
				  'header'             => "
# Socket Transaction Language file
# automatically generated by MIX
# note: do not change code enveloped by MIX_STL pragmas, it will be overwritten by script next time!

version 2.0

",
				  # internal static data structs
				  'hclocks'            => {},           # for storing per-clock-domain information
				  'hfnames'            => {},           # for storing field names
				  'lbody'              => [],
				  'ldomains'           => []
				 );
	
	# import regshell.<par> parameters from MIX package to class data; user can change these parameters in mix.cfg
	my $param;
	my @lmixparams = ('reg_shell.bus_clock', 
					  'reg_shell.bus_reset', 
					  'reg_shell.addrwidth', 
					  'reg_shell.datawidth',
					  'reg_shell.stl.initial_idle',
					  'reg_shell.stl.exclude_regs'
					 );
	foreach $param (@lmixparams) {
		my ($main, $sub, $subsub) = split(/\./,$param);
		if (ref $EH{$main}{$sub}) {
			$this->global($subsub => $EH{$main}{$sub}{$subsub});
			_info("setting parameter $param = ", $this->global->{$subsub}) if $this->global->{'debug'};
		} elsif (exists($EH{$main}{$sub})) {
			$this->global($sub => $EH{$main}{$sub});
			_info("setting parameter $param = ", $this->global->{$sub}) if $this->global->{'debug'};
		} else {
			_error("parameter \'$param\' unknown");
			if (defined (%EH)) { $EH{'sum'}{'errors'}++;};
		};
	};

	# make list of domains for generation
	if (scalar (@_)) {
		foreach my $domain (@_) {
			push @{$this->global->{'ldomains'}}, $this->find_domain_by_name_first($domain);
		};
	} else {
		foreach $href (@{$this->domains}) {
			push @{$this->global->{'ldomains'}}, $href->{'domain'};
		};
	};

	my ($o_domain, $o_field, $o_reg, $usedbits);
	# list of skipped  registers
	if (exists($this->global->{'exclude_regs'})) {
		@lexclude_regs = split(/\s*,\s*/,$this->global->{'exclude_regs'}); 
	};
	
	# iterate through all register domains
	foreach $o_domain (@{$this->global->{'ldomains'}}) {
		_info("generating code for domain ", $o_domain->name);
		
		# iterate through all the registers of the domain (sort by address)
		foreach $o_reg ( sort { $o_domain->get_reg_address($a) <=> $o_domain->get_reg_address($b) } @{$o_domain->regs}) {
			# $o_reg->display() if $this->global->{'debug'}; # debug
			my $reg_offset = $o_domain->get_reg_address($o_reg);
			my $usedbits = $o_reg->attribs->{'usedbits'};
			# BAUSTELLE
			$this->_ocp_access("write", $o_reg, $reg_offset, 0, 0);
			
			# iterate through all fields of the register
			#foreach $href (@{$o_reg->fields}) {
			#	$o_field = $href->{'field'};
			#};
		};
	};
	$this->display() if $this->global->{'debug'}; # dump Reg class object
	$this->_write_stl();
	1;
};

# generate a line in STL syntax
# for reads, the value is the expected value
# mask can be left empty
sub _ocp_access {
	my ($this, $access, $o_reg, $addr, $value, $mask) = @_;
	my $addr_str = "0x"._val2hex($this->global->{'addrwidth'}, $addr);
	my $value_str = "0x"._val2hex($this->global->{'datawidth'}, $value);
	my $mask_str = "";
	if ($mask ne "") {
		$mask_str = "0x"._val2hex($this->global->{'datawidth'}, $mask);
	};
	push @{$this->global->{'lbody'}}, "# register: " . $o_reg->name;
	push @{$this->global->{'lbody'}}, join(" ", $access, $addr_str, $value_str, "(".$mask_str.")");
};

# generate STL file
# uses existing file if there is one in the current dir
sub _write_stl {
	my ($this) = @_;
	my (@lresult);

	my $fname = join("_","regtest",map { $_->name() } @{$this->global->{'ldomains'}}) . "." . $this->global->{'file_suffix'};

	if (-e "$fname") {
		_info("reading existing file \'$fname\'");
		if (!_attach_file_to_list($fname, \@lresult)) {
			_error("could not open file \'$fname\' for reading");
			return 0;
		};
	} else {
		_info("creating new file \'$fname\'");
		# create an empty file
		push @lresult, "# ". $this->global->{'pragma_head_start'};
		push @lresult, "# ". $this->global->{'pragma_head_end'} , "";
		push @lresult, "# ". $this->global->{'pragma_body_start'};
		push @lresult, "# ". $this->global->{'pragma_body_end'}, "";
	};
	
	# insert a header
	$this->_gen_stl_head(\@lresult);

	# insert the body
	$this->_gen_stl_body(\@lresult);

	# write the new file
	if (!open(DHANDLE, ">$fname")) {
		_error("could not open file \'$fname\' for writing");
		return 0;
	} else {
		print DHANDLE  join("\n", @lresult), "\n";
		close(DHANDLE);
	};
	1;
};

# generate the file body
sub _gen_stl_body {
	my ($this, $lref) = @_;
	my @ltemp;

	my $pragma_start_pos = _get_pragma_pos($this->global->{'pragma_body_start'}, $lref);
	my $pragma_end_pos   = _get_pragma_pos($this->global->{'pragma_body_end'}, $lref);
	if ($pragma_start_pos == -1 or $pragma_end_pos == -1) {
		_warning("no pragmas found, skipping file body insertion");
		return 1;
	};
	push @ltemp, "", join("\n", @{$this->global->{'lbody'}}), "";
	splice @$lref, $pragma_start_pos + 1, $pragma_end_pos - $pragma_start_pos - 1, @ltemp;
	1;
};

# generate the file header
sub _gen_stl_head {
	my($this, $lref) = @_;
	my @ltemp;

	my $pragma_start_pos = _get_pragma_pos($this->global->{'pragma_head_start'}, $lref);
	my $pragma_end_pos   = _get_pragma_pos($this->global->{'pragma_head_end'}, $lref);
	if ($pragma_start_pos == -1 or $pragma_end_pos == -1) {
		_warning("no pragmas found, skipping file header insertion");
		return 1;
	};
	push @ltemp, split("\n", $this->global->{'header'}), "";
	push @ltemp, "# register test for domain(s) ".join(", ", map { $_->name() } @{$this->global->{'ldomains'}}), "";
	push @ltemp, "idle ".$this->global->{'initial_idle'};
	splice @$lref, $pragma_start_pos + 1, $pragma_end_pos - $pragma_start_pos - 1, @ltemp;
	1;
};

1;
