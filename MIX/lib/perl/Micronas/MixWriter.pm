# -*- perl -*---------------------------------------------------------------
#
# +-----------------------------------------------------------------------+
# |                                                                       |
# |   Copyright Micronas GmbH, Inc. 2002.                        |
# |     All Rights Reserved.                     |
# |                                                                       |
# |                                                                       |
# | THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF MICRONAS GMBH |
# | The copyright notice above does not evidence any actual or intended   |
# | publication of such source code.                                      |
# |                                                                       |
# +-----------------------------------------------------------------------+
#
# +-----------------------------------------------------------------------+
# | Project:    Micronas - MIX / Writer                                    |
# | Modules:    $RCSfile: MixWriter.pm,v $                                     |
# | Revision:   $Revision: 1.4 $                                             |
# | Author:     $Author: wig $                                  |
# | Date:       $Date: 2003/02/07 13:18:44 $                                   |
# |                                                                       |
# | Copyright Micronas GmbH, 2003                                |
# |                                                                       |
# | $Header: /tools/mix/Development/CVS/MIX/lib/perl/Micronas/MixWriter.pm,v 1.4 2003/02/07 13:18:44 wig Exp $                                                         |
# +-----------------------------------------------------------------------+
#
# The functions here provide the parsing capabilites for the MIX project.
# Take a matrix of information in some well-known format and convert it into
# intermediate format and/or source code files
#
# +-----------------------------------------------------------------------+
# |
# | Changes:
# | $Log: MixWriter.pm,v $
# | Revision 1.4  2003/02/07 13:18:44  wig
# | no changes
# |
# | Revision 1.3  2003/02/06 15:47:46  wig
# | added constant handling
# | rewrote bit splice handling
# |
# | Revision 1.2  2003/02/04 07:18:13  wig
# | Fixed header of modules
# |
# |
# |
# +-----------------------------------------------------------------------+
package  Micronas::MixWriter;

require Exporter;

  @ISA = qw(Exporter);
  @EXPORT = qw(
    generate_entities
    write_entities
    write_architecture
    write_configuration
    );            # symbols to export by default
  @EXPORT_OK = qw(
    );

our $VERSION = '0.01';

use strict;
use vars qw( %entities );

# Caveat: relies on proper setting of base, pgmpath and dir in main program!
use lib "$main::base/";
use lib "$main::base/lib/perl";
use lib "$main::pgmpath/";
use lib "$main::pgmpath/lib/perl";
use lib "$main::dir/lib/perl";
use lib "$main::dir/../lib/perl";

# use lib 'h:\work\x2v\lib\perl'; #TODO Rewrite that !!!!
use Log::Agent;
use Log::Agent::Priorities qw(:LEVELS);
use Tree::DAG_Node; # tree base class

use Micronas::MixUtils qw( mix_store db2array write_excel %EH );
use Micronas::MixParser qw( %hierdb %conndb );


# Prototypes
sub _write_entities ($$$);
sub replace_mac ($$);
sub write_architecture ();
sub strip_empty ($);
sub port_map ($$$$$);

# Internal variables

#
# Templates ...
#
sub tmpl_enty () {

# TODO: Read that templates in from default location (e.g. a company default)
$EH{'template'}{'vhdl'}{'enty'}{'head'} = <<'EOD';
-- -------------------------------------------------------------
--
-- Generated Entity Declaration for %ENTYNAME%
--
-- Generated by %USER%
--           on %DATE%
--
-- !!! Do not edit this file! Autogenerated by MIX !!!
-- %H%Author%H%
-- %H%Id%H%
-- %H%Date%H%
-- %H%Log%H%
--
-- Based on Mix Entity Template built into $RCSfile: MixWriter.pm,v $
-- $Id: MixWriter.pm,v 1.4 2003/02/07 13:18:44 wig Exp $
--
-- Generator: %0% Version: %VERSION%, wilfried.gaensheimer@micronas.com
-- (C) 2003 Micronas GmbH
--
-- --------------------------------------------------------------
Library IEEE;
Use IEEE.std_logic_1164.all;
-- Use IEEE.std_logic_arith.all;
--

EOD

$EH{'template'}{'vhdl'}{'enty'}{'body'} = <<'EOD';
--
-- Start of Generated Entity %ENTYNAME%
--
entity %ENTYNAME% is
        -- Generics:
	generic(
            %GENERIC%
	);
	
	-- Generated Port Declaration:
	port(
                %PORT%
        );
end %ENTYNAME%;
--
-- End of Generated Entity %ENTYNAME%
--

EOD

$EH{'template'}{'vhdl'}{'enty'}{'foot'} = <<'EOD';
--
--!End of Entity/ies
-- --------------------------------------------------------------
EOD

}

#
# Architecture Templates ...
#
sub tmpl_arch () {

$EH{'template'}{'vhdl'}{'arch'}{'head'} = <<'EOD';
-- -------------------------------------------------------------
--
-- Generated Architecture Declaration for %ARCHNAME%
--
-- Generated by %USER%
--           on %DATE%
--
-- !!! Do not edit this file! Autogenerated by MIX !!!
-- %H%Author%H%
-- %H%Id%H%
-- %H%Date%H%
-- %H%Log%H%
--
-- Based on Mix Architecture Template built into $RCSfile: MixWriter.pm,v $
-- $Id: MixWriter.pm,v 1.4 2003/02/07 13:18:44 wig Exp $
--
-- Generator: %0% %VERSION%, wilfried.gaensheimer@micronas.com
-- (C) 2003 Micronas GmbH
--
-- --------------------------------------------------------------
Library IEEE;
Use IEEE.std_logic_1164.all;
Use IEEE.std_logic_arith.all;

--
EOD

$EH{'template'}{'vhdl'}{'arch'}{'body'} = <<'EOD';
--
-- Start of Generated Architecture %ARCHNAME%
--
architecture %ARCHNAME% of %ENTYNAME% is 
	--
	-- Components
	--

%COMPONENTS%

	--
	-- Nets
	--

%SIGNALS%

%CONSTANTS%

begin

	--
	-- Generated Concurrent Statements
	--

%CONCURS%

	--
	-- Generated Instances
	--

%INSTANCES%

end %ARCHNAME%;

EOD

$EH{'template'}{'vhdl'}{'arch'}{'foot'} = <<'EOD';
--
--!End of Architecture/s
-- --------------------------------------------------------------
EOD

#	'vhdl' =>{
#	    'conf' => "VHDL Configuration Template String t.b.d.",
#	    'arch' => "VHDL Architecture Template String t.b.d.",
#	},
#	'verilog' =>{
#	    'wrap' => "Verilog Wrapper Template String",
#	    'file' => "Verilog File Template String",
#	},
#   },

}

sub tmpl_conf () {

# TODO: Read that templates in from default location (e.g. a company default)
$EH{'template'}{'vhdl'}{'conf'}{'head'} = <<'EOD';
-- -------------------------------------------------------------
--
-- Generated Configuration for %CONFNAME%
--
-- Generated by %USER%
--           on %DATE%
--
-- !!! Do not edit this file! Autogenerated by MIX !!!
-- %H%Author%H%
-- %H%Id%H%
-- %H%Date%H%
-- %H%Log%H%
--
-- Based on Mix Entity Template built into $RCSfile: MixWriter.pm,v $
-- $Id:%
--
-- Generator: %0% Version: %VERSION%, wilfried.gaensheimer@micronas.com
-- (C) 2003 Micronas GmbH
--
-- --------------------------------------------------------------

EOD

$EH{'template'}{'vhdl'}{'conf'}{'body'} = <<'EOD';
--
-- Start of Generated Configuration %CONFNAME% / %ENTYNAME%
--
configuration %CONFNAME% of %ENTYNAME% is
        FOR %ARCHNAME%

	    %CONFIGURATION%

	END FOR; 
end %CONFNAME%;
--
-- End of Generated Configuration %CONFNAME%
--

EOD

$EH{'template'}{'vhdl'}{'conf'}{'foot'} = <<'EOD';
--
--!End of Configuration/ies
-- --------------------------------------------------------------
EOD

}

####################################################################
## generate_entities
## scan through hierachy and set up entities
####################################################################

=head2

generate_entities () {

Scan all of hierachy and create consistent, checked list of entities.
An entity has a name and a portmap (generic map).

Data structure will look like $entities{$name}{$port}{type|from|to|mode}.
Type will be generic or std_logic or std_ulogic ....

Relies on $hierdb{inst}{::conn}{::in|::out} to exist!

TODO: Usage of hierdb is not nice. Search for a better way.
TODO: Generics and inout mode ....

=cut

sub generate_entities () {

    for my $i ( keys( %hierdb ) ) {
        unless( exists ( $hierdb{$i}{'::entity'} ) ) {
            logwarn("Skipping instance $i with undefined entity!");
            next;
        }
        my $ent = $hierdb{$i}{'::entity'};
        if ( defined( $entities{$ent} ) ) {
            merge_entity( $ent, $hierdb{$i} );
        } else {
            create_entity( $ent, $hierdb{$i} );
        }
    }
    return;
}

#
# Create a dummy entity entry and compare the "signatures"
# Merge into old one
#
sub merge_entity ($$) {
    my $ent = shift;
    my $inst = shift;

    my %ient;
    if ( exists( $inst->{'::conn'}{'in'} ) ) {
        %ient = _create_entity( 'in', $inst->{'::conn'}{'in'} );
    } else {
        # Create dummy entry, no port ...
        %{$ient{'-- NO IN PORTs'}} = (
            'type' => '',
            'mode' => '',
            'high' => '',
            'low' => '',
        );
    }

    if ( exists( $inst->{'::conn'}{'out'} ) ) {
        %ient = ( %ient, _create_entity( 'out', $inst->{'::conn'}{'out'} ) );
    } else {
        # Create dummy entry, no port ...
        %{$ient{'-- NO OUT PORTs'}} = (
            'type' => '',
            'mode' => '',
            'high' => '',
            'low' => '',
        );
    }

    # $eq will be 1 if acceptable differences exist, else 0!
    # compare_merge_entities will sum up acceptable differences in %entities and
    # complain verbosely otherwise
    my $eq = compare_merge_entities( $ent, $entities{$ent}, \%ient );
    #TODO: use result for further decision making

    #TODO: __LEAF__, another name??
    if ( $inst->{'::treeobj'}->daughters ne "0" ) {
	$ient{'__LEAF__'}++;
    }

} # create_entity


sub compare_merge_entities ($$$) {
    my $ent = shift;
    my $rent = shift;
    my $rnew = shift;

    #    %{$entity{$ent}{'-- NO OUT PORTs'}} = (
    #       'type' => '',
    #       'mode' => '',
    #       'high' => '',
    #       'low' => '',

    my $eflag = 1; # Is equal

    # for all ports:    
    for my $p ( keys( %$rent ) ) {
        # Skip that if it does not exist in the new port map
	next if ( $p eq "__LEAF__" );
        unless( exists( $rnew->{$p} ) ) {
	    if ( $p ne "-- NO OUT PORTs" and $p ne "-- NO IN PORTs" ) {
		logwarn( "Missing port $p in entity $ent redeclaration, ignoreing!" );
		$eflag  = 0;
	    }
            next;
        }


        # type has to match
        if ( $rent->{$p}{'type'} ne $rnew->{$p}{'type'} ) {
            logwarn( "Entity type mismatch for entity $ent!" );
            $eflag = 0;
            next; #TODO: How should we handle that properly?
        # mode has to match
        } elsif ( $rent->{$p}{'mode'} ne $rnew->{$p}{'mode'} ) {
            logwarn( "Entity mode mismatch for enitity $ent!" );
            $eflag = 0;
            next;
        }
        # Take larger 'high' value
        if ( defined( $rnew->{$p}{'high'} ) and $rnew->{$p}{'high'} =~ m/^(\d+)$/o ) {
            my $val = $1;
            my $re = $rent->{$p}{'high'};
            unless ( defined( $re ) and
                     $re =~ m/^(\d+)$/o and 
                     $re >= $val ) {
                $rent->{$p}{'high'} = $val;
            }
        }
        # Take lower 'low' value
        if ( defined( $rnew->{$p}{'low'} ) and $rnew->{$p}{'low'} =~ m/^(\d+)$/o ) {
            my $val = $1;
            my $re = $rent->{$p}{'low'};
            unless ( defined( $re ) and
                     $re =~ m/^(\d+)$/o and 
                     $re <= $val ) {
                $rent->{$p}{'low'} = $val;
            }
        }
        delete( $rnew->{$p} ); # Done
    }

    # Now we add up the rest of $rnew ...
    for my $p ( keys( %$rnew ) ) {
        #
	if ( $p ne "-- NO OUT PORTs" and $p ne "-- NO IN PORTs" ) {
	    logwarn( "Declaration for entity $ent extended by $p!" );
	    $eflag = 0;
    	}
        $rent->{$p} = $rnew->{$p}; # Copy
    }
    return $eflag;
}

sub create_entity ($$) {
    my $ent = shift; # Entity name
    my $inst = shift; # Reference to instance.
    
    if ( exists( $inst->{'::conn'}{'in'} ) ) {
        %{$entities{$ent}} = _create_entity( 'in', $inst->{'::conn'}{'in'} );
    } else {
        # Create dummy entry, no port ...
        %{$entities{$ent}{'-- NO IN PORTs'}} = (
            'type' => '',
            'mode' => '',
            'high' => '',
            'low' => '',
        );
    }

    if ( exists( $inst->{'::conn'}{'out'} ) ) {
        %{$entities{$ent}} = ( %{$entities{$ent}} , _create_entity( 'out', $inst->{'::conn'}{'out'} ));
    } else {
        # Create dummy entry, no port ...
        %{$entities{$ent}{'-- NO OUT PORTs'}} = (
            'type' => '',
            'mode' => '',
            'high' => '',
            'low' => '',
        );
    }

    if ( $inst->{'::treeobj'}->daughters() ne "0" ) {
	$entities{$ent}{'__LEAF__'}++;
    } else {
	$entities{$ent}{'__LEAF__'} = 0;
    }
} # create_entity

sub _create_entity ($$) {
    my $io = shift;
    my $ri = shift;

    my %res = ();
    for my $i ( keys( %$ri ) ) {
        my $sport = $ri->{$i};
	
        unless( defined( $conndb{$i} ) ) {
            logwarn("Illegal signal name $i referenced!");
            next;
        }
	
	#
	# Iterate through all inst/ports ...
	#
        for my $port ( keys( %$sport ) ) {
            # my $index = $signal->{$port};
            # for my $ii ( split( ',', $index ) ) {
            #    #mode = in

	    #TODO: Catch all bad cases before in seperate check stage!
	    
	    my $h = -100000; # Absurd value .... jsut to avoid undef
	    my $l = -100000;  # Absurd value ....

	    # but may differ for this port ....
	    for my $ii ( split( ',', $$sport{$port} ) ) {
		my $thissig = $conndb{$i}{'::' . $io}[$ii]; # Get this signal ...
		# Find max port bounds ....
		#TODO: What if there are holes? Sanity checks need to be done before ...
		if ( defined $thissig->{'port_f'} ) { # This should be a bus ...
		    if ( $h < $thissig->{'port_f'} ) { $h = $thissig->{'port_f'}; }
		} # else {
		    
		if ( defined $thissig->{'port_t'} ) { # This should be a bus ...
		    if ( $l == -100000 or $l > $thissig->{'port_t'} ) { $l = $thissig->{'port_t'}; }
		}
	    }
	    if ( $l == -100000 ) {
		$l = undef;
	    }
	    if ( $h == -100000 ) {
		$h = undef;
	    }

	    my $type = $conndb{$i}{'::type'};

	    # If connecting single signals to a bus-port, make type match!
	    # TODO SPECIAL trick ???? Check if that is really so clever ....
	    if ( ( $type eq "std_logic" or
		 $type eq "std_ulogic" ) and
		 defined( $h ) and defined( $l ) and
		 ( $h ne $l ) ) {
		$type = $type . "_vector";
		logtrc( "INFO", "autoconnecting single signal $i to bus port $port" );
	    }

	    my $m = $conndb{$i}{'::mode'};
	    my $mode = "__E_MODE_DEFAULT_ERROR__";
	    if ( $m ) { # not empty
		if ( $m =~ m,IO,io ) { $mode = "inout"; } 		# inout mode!
		elsif ( $m =~ m,B,io ) { $mode = "%BUFFER%"; }	# buffer
		elsif ( $m =~ m,(G|C),io ) { $mode = $m; }		# generic and constant
		elsif ( $m =~ m,S,io ) { $mode = $io; }			# signal -> derive from i/o
		elsif ( $m =~ m,I,io ) {						# warn if mode mismatches
		    #TODO: Need to look at all connections ....
		    if ( $io eq "out" ) {
			#!wig20030207:off: logwarn( "mode mismatch for signal $i, port $port: $m ne $io" );
			$conndb{$i}{'::comment'} .= ",__W_MODE_MISMATCH"; #TODO:  __E??
			$mode = $io;
		    } else {
			$mode = "in";
		    }
		} elsif ( $m =~ m,O,io ) {					# xls says O!
		    if ( $io eq "in" ) {
			#!wig20030207:off: logwarn( "mode mismatch for signal $i, port $port: $m ne $io" );
			$conndb{$i}{'::comment'} .= ",__W_MODE_MISMATCH"; #TODO: __E??
			$mode = $io;
		    } else {
			$mode = "out";
		    }
		} else {
		    logwarn( "ERROR: TODO mode defaults to bad value for signal $i\n" );
		    $mode = $io;
		}
	    } else { # if no mode was specified, it defaults to S, which means to autodetecte in/out
		$mode = $io;
	    }

	    #
	    # Duplicate signals will be caught by the compare_and_merge_entitiy
	    # function
	    #
            %{$res{$port}} = (
                'mode' => $mode, #TODO: do some sanity checking! e.g. high, low might be
					# undefined, check if bus vs. bit. and consider the ::mode!
                'type' => $type,  #|| 'signal', # type defaults to signal
                'high' => $h,  # set default to '' string
                'low'  => $l,   # set default to '' string
            );
        }
	# $res{'__SIGNAL__'}{$i}=; # Remember signals connected
    }
    return %res;
}

####################################################################
## write_entities
## write entities
####################################################################

=head2

write_entities () {

Write entity into output file(s).

=cut

sub write_entities () {

    # Set up entity template;
    tmpl_enty();
    
    # open output file
    my $efname = $EH{'outenty'};
    if ( $efname =~m/^ENTY/o ) {
	# Write each entity in a file of it's own
	for my $i ( sort( keys( %entities ) ) ) {

		# Skip leaf entities ...
    		if ( $EH{'output'}{'generate'}{'enty'} eq "noleaf" and
		    $entities{$i}{'__LEAF__'} == 0 ) {
		    next;
		}
		my $filename = $i . $EH{'postfix'}{'POSTFIX_ENTY'} . "-e.vhd";
	    	_write_entities( $i, $filename, \%entities )
	}
    } else {
	_write_entities( "__COMMON__", $efname, \%entities );
    }

    return;

}


#
# Do the work: Collect ports and generics from %entities.
# Print out and also save port and generics for later reusal (e.g. architecture)
#
sub _write_entities ($$$) {
    my $ehname = shift;
    my $file = shift;
    my $ae = shift;

    my %macros = %{$EH{'macro'}};

    $macros{'%ENTYNAME%'} = $ehname;
    $macros{'%VERSION%'} = $::VERSION;
    $macros{'%0%'} = $::pgm;
    $macros{'%DATE%'} = "" . localtime();
    $macros{'%USER%'} = "W_UNKNOWN_USERNAME";
    if ( $^O =~ m,^mswin,io ) {
	if ( defined( $ENV{'USERNAME'} ) ) {
	        $macros{'%USER%'} = $ENV{'USERNAME'};
	}
    } elsif ( defined( $ENV{'LOGNAME'} ) ) {
		$macros{'%USER%'} = $ENV{'LOGNAME'};
    }

    if ( -r $file ) {
	logtrc(INFO, "Entity declaration file $file will be overwritten!" );
    }
    
    unless( open( ENTY, "> $file" ) ) {
        logwarn( "Cannot open file $file to write entity declarations: $!" );
        return;
    }

    # Add header
    my $tpg = $EH{'template'}{'vhdl'}{'enty'}{'body'};
    my $et = replace_mac( $EH{'template'}{'vhdl'}{'enty'}{'head'}, \%macros);    

    #
    # Collect generics and ports ...
    #
    my @keys = ( $ehname eq "__COMMON__" ) ? keys( %$ae ) : ( $ehname );
    for my $e ( sort( @keys ) ) {

	# Do not write entities for leaf blocks ...
	#TODO: Check
	if ( $EH{'output'}{'generate'}{'enty'} eq "noleaf" and
	    $ae->{$e}{'__LEAF__'} == 0  ) {
		next;
	}
	if ( $e eq "W_NO_ENTITY" ) { next; };
	
	$macros{'%ENTYNAME%'} = $e;
	my $gent = "\t\t\t-- generated\n";
	my $port = "\t\t\t-- generated\n";
	my $pd = $ae->{$e};
	for my $p ( sort ( keys( %{$pd} ) ) ) {
	    next if ( $p eq "__LEAF__" );
	    
	    my $pdd = $pd->{$p};
	    if ( $pdd->{'mode'} =~ m,^\s*(const|C),io ) {
		# $gent .= "\t\t\t -- " . $p . "\t: " . $pdd->{'type'} . "\t:= " . $pdd->{'value'} . "\n";
		next;
	    } elsif ( $pdd->{'mode'} =~ m,^\s*(generic|G),io ) {
		# Generic
		$gent .= "\t\t\t" . $p . "\t: " . $pdd->{'type'} . "\t:= " . $pdd->{'value'} . "\n";
	    } elsif (	defined( $pdd->{'high'} ) and
			defined( $pdd->{'low'} ) and
			$pdd->{'high'} =~ m/^\d+$/o and $pdd->{'low'} =~ m/^\d+$/ ) {
		# Signal ...from high to low. Ignore everything not matching
		# this pattern (e.g. only one bound set ....)
		if ( $pdd->{'high'} == $pdd->{'low'} ) {
		    if ( $pdd->{'high'} == 0 ) {
			# Special case: single pin "bus" -> reduce to it ....
			logtrc( "INFO:4", "Port $p of entity $e one bit wide, reduce to signal\n" );
			$pdd->{'type'} =~ s,_vector,,; # Try to strip away trailing vector!
			$pdd->{'low'} = undef;
			$pdd->{'high'} = undef;
			$port .= "\t\t\t" . $p . "\t: " . $pdd->{'mode'} . "\t" . $pdd->{'type'} .
			    "; -- __W_AUTO_REDUCED_BUS2SIGNAL\n";
		    } else {
			logwarn( "Port $p of entity $e one bit wide, missing lower bits\n" );
			$port .= "\t\t\t" . $p . "\t: " . $pdd->{'mode'} . "\t" . $pdd->{'type'} .
			    "(" . $pdd->{'high'} . "); -- __W_SINGLEBITBUS\n";
		    }
		} elsif ( $pdd->{'high'} > $pdd->{'low'} ) {
		    $port .= "\t\t\t" . $p . "\t: " . $pdd->{'mode'} . "\t" . $pdd->{'type'} .
			"(" . $pdd->{'high'} . " downto " . $pdd->{'low'} . ");\n";
		} else {
	    	    $port .= "\t\t\t" . $p . "\t: " . $pdd->{'mode'} . "\t" . $pdd->{'type'} .
			"(" . $pdd->{'high'} . " to " . $pdd->{'low'} . ");\n";
		}
	    } else {
		    $port .= "\t\t\t" . $p . "\t: " . $pdd->{'mode'} . "\t" . $pdd->{'type'} . ";\n";
	    }
	}
	#Get rid of trailing ;, replace %MACs%
	$port =~ s/;\n$/\n\t\t\t-- end of generated port/;
	$gent =~ s/;\n$/\n\t\t\t-- end of generated generic/;

	# Store ports and generics
	$entities{$e}{'__PORTTEXT__'} = $port . "\n";
	$entities{$e}{'__GENERICTEXT__'} = $gent . "\n";
	
	$macros{'%PORT%'} = $port;
	$macros{'%GENERIC%'} = $gent;

	$et .= replace_mac( $tpg, \%macros );
	
    }
    
    $et .=  $EH{'template'}{'vhdl'}{'enty'}{'foot'};

    $et = replace_mac( $et, \%macros );

    $et = strip_empty( $et );
    
    print( ENTY $et );

    close( ENTY ) or
	logwarn( "Cannot close file $file: $!" );
}

sub replace_mac ($$) {
    my $text = shift;
    my $rmac = shift;

    my $mkeys = "(" . join( '|', keys( %$rmac ) ) . ")";

    $text =~ s/$mkeys/$rmac->{$1}/mg;

    return $text;
}

#         'entities' => {
#                         'ddrv' => {
#					'__LEAF__' = 0...,
#                                      'current_time' => {
#                                                          'low' => '0',
#                                                          'mode' => 'in',
#                                                          'high' => '3',
#                                                          'type' => 'std_ulogic_vector'
#                                                        },
#                                      'key_buffer' => {
#                                                        'low' => '0',
#                                                        'mode' => 'in',
#                                                        'high' => '3',
#                                                        'type' => 'std_ulogic_vector'
#                                                      },	    

####################################################################
## write_architecture
## write architecture VHDL files
####################################################################

=head2

write_architecture () {

Write architecture into output file(s).

=cut

sub write_architecture () {

    # Set up architecture template;
    tmpl_arch();
    
    # open output file
    my %seen = ();
    my $efname = $EH{'outarch'};
    if ( $efname =~m/^ARCH/o ) {
	# Write each architecture in a file of it's own
	for my $i ( sort( keys( %hierdb ) ) ) {
		# Skip it if it was seen before
		#TODO: sort be order of hierachy
		#TODO: will that be unique?
		my $e = $hierdb{$i}{'::entity'};

	    	# Should we print it?
		next if ( $e eq "W_NO_ENTITY" );
		if ( $EH{'output'}{'generate'}{'arch'} eq "noleaf" and
		    not $hierdb{$i}{'::treeobj'}->daughters ) {
		    next;
		}
		unless ( exists( $seen{$e} ) ) {
		    $seen{$e} = 1;  #TODO ?????
		    my $filename = $e . $EH{'postfix'}{'POSTFIX_ARCH'} . "-a.vhd";
		    _write_architecture( $i, $e, $filename, \%hierdb );
		}
	}
    } else {
	_write_architecture( "__COMMON__", "__COMMON__", $efname, \%hierdb );
    }

    return;

}

####################################################################
## gen_instmap
## generate an instance map 
####################################################################

=head2

gen_instmap ($) {

Return an port map for the instance and a list of in and out signals

=cut

sub gen_instmap ($) {
    my $inst = shift;

    #
    #TODO: Generic map!
    #

    my $map = "\t\t\t-- Generated Instance Port Map for $inst\n";
    my @in = ();
    my @out = ();
    my $enty = $hierdb{$inst}{'::entity'};

    $map .= "\t\t\t$inst: $enty PORT MAP(\n";

    #
    # Iterate through all signals attached to that instance:
    #TODO: make port map a better data structure to be joined by this
    # module and the %entities data structure
    #
    my $rinstc = $hierdb{$inst}{'::conn'}; #TODO Better use entitiy??!!
    $map .= port_map( 'in', $inst, $enty, $rinstc->{'in'}, \@in );
    # for my $s ( sort( keys( %{$rinstc->{'in'}}) )  ) {
	#for my $p ( sort( keys( %{$rinstc->{'in'}{$s}} ) ) ) {
	#$map .= "\t\t\t\t$p => $s,\n";
	#push( @in, $s );
	#}
    #}
    $map .= port_map( 'out', $inst, $enty, $rinstc->{'out'}, \@out );
    
    #for my $s ( sort( keys( %{$rinstc->{'out'}} ) ) ) {
	#for my $p ( sort( keys( %{$rinstc->{'out'}{$s}} ) ) ) {
	#    $map .= "\t\t\t\t$p => $s,\n";
	#    push( @out, $s );
	#}
    #}

    # Remove trailing ,    
    $map =~ s/,\s*\n$/\n/o;
    $map .= "\t\t\t);\n\t\t\t-- End of Generated Instance Port Map\n";
    
    return( $map, \@in, \@out);
}

#
# create port map, handels bus slices ...
#
# Input:
#  $io  = 'in' or 'out'
#  $inst = instancename
#  $enty = entityname
#  $ref = reference to $hierdb{$i}{::conn}{$io}
#  $rio = reference to array keeping in's and out's (output!)
#
sub port_map ($$$$$) {
    my $io = shift;
    my $inst = shift;
    my $enty = shift;
    my $ref = shift;
    my $rio = shift;

    # Check if port width equals signal width.
    # Use simple assigment if yes, else slice bus
    my $map = "";
    for my $s ( sort( keys( %$ref ) ) ) {
	if ( $conndb{$s}{'::mode'} =~ m,^\s*(C),io ) {
	    push( @$rio, $s );
	    next;
	} # Skip constants
	
	my $sf = $conndb{$s}{'::high'}; # Set signal high bound
	unless( defined( $sf ) and $sf ne '' ) { $sf = '__UNDEF__'; }
	
	my $st = $conndb{$s}{'::low'}; 	# Set signal low bound
	unless( defined( $st ) and $st ne '' ) { $st = '__UNDEF__'; }

	for my $p ( sort( keys( %{$ref->{$s}} ) ) ) {
	    # $p has port name
	    # $s has signal name
	    my $pf = $entities{$enty}{$p}{'high'};
	    unless( defined( $pf ) and $pf ne '' ) { $pf = '__UNDEF__'; }

	    my @cm = (); # Connections to this port ....
	    my $pt = $entities{$enty}{$p}{'low'};
	    unless( defined( $pt ) and $pt ne '' ) { $pt = '__UNDEF__'; }

	    for my $n ( split( ',', $ref->{$s}{$p} ) ) {
		#
		# Read out the actual connection data
		#  $conn->{inst}, $conn->{port}
		#  $conn->{port_f}, $conn->{port_t},
		#  $conn->{sig_f}, $conn->{sig_t}		
		my $conn = $conndb{$s}{'::' . $io}[$n];
		add_conn_matrix( $p, $s, \@cm, $conn );
	    }

	    $map .= print_conn_matrix( $p, $pf, $pt, $s, $sf, $st, \@cm );
	}
	push( @$rio, $s );
    }
    return $map;
}

#
# Set up an array for each pin of a port, indexing a given signal!
#
#TODO: Handle connection of different signals to port?
# Handle duplicate connection of one signal to several pins ...
#
sub add_conn_matrix ($$$$) {
    my $port = shift;
    my $signal = shift;
    my $matrix = shift;
    my $conn = shift;

    my $cpf = $conn->{port_f} || '0';  # undef -> 0
    my $cpt = $conn->{port_t} || '0';  # undef -> 0
    my $max = $cpf;
    my $min = $cpt;
    my $dirf = 1; # Normal from downto to
    
    if ( $cpt > $max ) { $max = $cpt; $min = $cpf; $dirf = -1;  };

    my $csf = $conn->{sig_f} || '0';  # undef -> 0
    my $cst = $conn->{sig_t} || '0';  # undef -> 0
    my $smax = $csf;
    my $smin = $cst;
    my $sdirf = 1;
    
    if ( $cst > $smax ) { $smax = $cst; $smin = $csf; $sdirf = -1; };

    if ( $smax - $smin != $max - $min ) {
	logwarn("__E_SLICE_WIDTH_MISMATCH:signal $signal ($smax downto $smin) to port $port ($max downto $min)!");
	return undef;
	# return( "\t\t-- __E_SLICE_WIDTH_MISMATCH for signal $signal connected to port $port!" );
    }

    #TODO: Extended testing ....
    if ( $dirf == $sdirf ) {
	for my $i ( $min .. $max ) {
	    if ( defined( $matrix->[$i] ) ) { # Seen before ...
		if ( $matrix->[$i] ne $smin - $min + $i ) {
		    logwarn("__E_PORT_SIGNAL_CONFLICT: $port($i) connecting signal $signal" . ( $smin + $i ) .
			    " or " . $matrix->[$i] . "!" );
		}
	    } else {
		 $matrix->[$i] = $smin - $min + $i;
	    }
        }
    } else {
	for my $i ( $min .. $max ) {
	    if ( defined( $matrix->[$i] ) ) { # Seen before ...
		if ( $matrix->[$i] ne $smax - $max - $i ) {
		    logwarn("__E_PORT_SIGNAL_CONFLICT: $port($i) connecting signal $signal" . ( $smin + $i ) .
			    " or " . $matrix->[$i] . "!" );
		}
	    } else {	    
		$matrix->[$i] = $smax - $min - $i;
	    }
        }
    }

    # Return 1 if signal and port slice are the same !!    
    if ( $cpt eq $cst and $cpf eq $csf ) {
	return 1;
    } else {
	return 0;
    }
}

sub print_conn_matrix ($$$$$$$) {
    my $port = shift;
    my $pf = shift;
    my $pt = shift;
    my $signal = shift;
    my $sf = shift;
    my $st = shift;
    my $rcm = shift;
    
    #
    # Simple case: everything is in sync and o.k. ( matrix index equals signal pin number)
    #
    my $t = "";
    my $lb = undef;
    my $ub = $#$rcm;
    my $lstart = 0;

    # $ub = 0 and $p[f|t] = __UNDEF__ and $s[f|t] = __UNDEF__
    # and $rcm->[0] = 0  -> single pin assignment
    if ( $ub == 0 and
	 $pf eq "__UNDEF__" and $pt eq "__UNDEF__" and
	 $sf eq "__UNDEF__" and $st eq "__UNDEF__" and
	 $rcm->[0] == 0 ) {
	    $t .= "\t\t\t$port => $signal,\n";
	    return $t;
    }

    # Run through cm and see if everything is filled and ordered   
    my $fflag = $ub;
    my $cflag = 1;
    #TODO: reverse flag ...: my $rflag = 1;
    for my $i ( 0..$ub ) {
	if ( not defined( $lb ) ) {
	    if ( defined( $rcm->[$i] ) ) {
		$lb = $i; # Find start point, offset ....
	    } else {
		next;
	    }
	}
	unless ( defined( $rcm->[$i] ) ) {
	    $fflag = $i - 1;
	    last;
	}
	if ( $rcm->[$i] ne $i + $rcm->[$lb] ) {
	    $cflag = 0;
	}
    }
	
    if ( $cflag and $fflag == $ub ) { # Full port <-> signal
	if ( $pf eq $pt and defined( $lb ) and $lb  == $ub ) {
	    # Single bit port .... connected to bus slice
	    # TODO: do more checking ...
	    if ( $pf eq "__UNDEF__" ) {
		$t .= "\t\t\t$port => $signal(" . $rcm->[$ub] . "),\n";
	    } else {
		$t .= "\t\t\t$port($pf) => $signal(" . $rcm->[$ub] . "),\n";
	    }
	} elsif ( $ub eq $sf ) { # Should == be used here instead?
	    $t .= "\t\t\t$port => $signal,\n";
	} elsif ( $ub < $sf ) {
	    $t .= "\t\t\t$port => $signal($ub downto 0),\n";
	}
	return $t;

    #
    #TODO: catch the most important cases here
    #
    } else { # Output each single bit!!
	for my $i ( 0..$ub ) {
	    if ( defined( $rcm->[$i] ) ) {
		$t .= "\t\t\t$port(" . $i . ") => $signal(" . $rcm->[$i] ."),\n";
	    }
	}
    }
    return $t;

}

=head2

OLD STUFF, REMOVE ....

	    # Various old possibilities ....
	    # Found hole ....
	    # Output port found up to now
	    # Look if signal were assigned in row so far ....
	    if ( defined( $lb ) and $lb eq $i ) { #will never happen!
		$t .= "\t\t\t$p($i) => $s(" . $rcm[$i] . ")";
		$lb = undef;
		next;
	    }
	    if ( defined( $lb ) and $lb eq ( $i - 1 ) ) { #Connect single pin to bit of signal
		$t .= "\t\t\t$p($lb) => $s(" . $rcm[$lb] . ")"; #TODO: check if signal isn't a single bit
		$lb = undef;
		next;
	    } else {
		for my $ii ( $lb..($i - 1) ) {
		    if ( $sign = $rcm->[$ii] 
		    $t .= "\t\t\t$p(" . ( $i - 1 ) ." downto " . $lb .") => $s";
		}
	    }  
	} else {
	    if ( $#tmp >= 0 ) {
	    if ( $rcm->[$i] ne $i ) { # No longer in order ...
		$t .= "\t\t\t$p(" . ( $i - 1 ) ." downto " . $lb .") => $s(" . 
		
	if ( not defined( $rcm->[$i] ) { # Hole in the pin definition ...
	    if ( $lstart - $i == 0 ) { #Just one pin
		    $t
	    
	
	
    	    if ( $sh eq $ph and $sl eq $pl ) {
		#
		# high and low are equal or undefined ..
		# simple case, no further processing done ....
		# but might be to optimistic (due to missing pins, which should not get
		# connected ...
		#
		$map .= "\t\t\t\t$p => $s,\n";
	    } else {
		# Bus slice ???
		if ( $sh eq '__UNDEF__' and $sl eq '__UNDEF__' ) {
		    # port(N) => SIGNAL
		    #TODO: is that valid???
		    if ( $ph eq $pl ) {
			$map .= "\t\t\t\t$p($ph) => $s,\n";
		    } else {
			$map .= "\t\t-- __E_BOUND_MISMATCH $p ( $ph downto $pl ) => $s,\n";
			logwarn( "ERROR: BOUND_MISMATCH port $p, signal $s in entity $enty!" );
		    }
		} elsif ( $ph eq $pl ) {
		    # Port is one bit (slices have to be combined by previous checks)!
		    if ( $ph eq "__UNDEF__" or $ph eq "0" ) {
			$map .= "\t\t\t\t$p => $s( XXXX ),\n";
		    } else {
			$map .= "\t\t\t\t$p => $s( XXXX ), -- __W_CHECK_BOUNDS\n";
		    }
		} else { # slice of bus attached to (slice) of port
		    #TODO: Check if all s* and p* are numbers!
		    my $swidth = $sh - $sl;
		    my $pwidth = $ph - $pl;
		    if ( $swidth == $pwidth ) { # Slice matches ...
			if ( $sl == 0 ) {
			    $map .= "\t\t\t\t$p($ph downto $pl) => $s,\n";
			} elsif ( $pl == 0 ) {
			    $map .= "\t\t\t\t$p => $s($sh downto $sl),\n";
			} else {
			    $map .= "\t\t\t\t$p($ph downto $pl) => $s($sh downto $sl),\n";
			}
		    } elsif ( $swidth < $pwidth ) { #Port is wider than signal ????
			# Attach $pwidth bits of signal to port ....
			logtrc( "INFO", "__W_SIGNAL_PORT_WIDTH_MISMATCH port $p, signal $s in entity $enty!" );
			$map .= "\t\t\t\t$p(" . ( $pl + $swidth ) . " downto $pl) => $s($sh downto $sl),\n";
		    } else { # Signal is wider than port ....
			my $warn = "";
			unless ( $s =~ m,%(LOW|HIGH),io ) {
			    logwarn( "ERROR: BOUND_MISMATCH port $p, signal $s in entity $enty!" );
			    $warn = "-- __W_BOUND_MISMATCH";
			}
			$map .= "\t\t\t\t$p => $s(" . ( $sl + $pwidth ) . " downto $sl), $warn\n";
		    }
		}
	    }
	    push( @$rio, $s );
	}
    }
    return $map;
}

=cut

#
# Do the work: Collect ports and generics from %entities.
# Print out and also save port and generics for later reusal (e.g. architecture)
#
sub _write_architecture ($$$$) {
    my $instance = shift;
    my $entity = shift;
    my $filename = shift;
    my $ae = shift;

    my %macros = %{$EH{'macro'}}; # Take predefined macro replacement set

    $macros{'%ENTYNAME%'} = $entity;
    $macros{'%ARCHNAME%'} = $entity . $EH{'postfix'}{'POSTFIX_ARCH'};
    $macros{'%VERSION%'} = $::VERSION;
    $macros{'%0%'} = $::pgm;
    $macros{'%DATE%'} = "" . localtime();
    $macros{'%USER%'} = "W_UNKNOWN_USERNAME";
    if ( $^O =~ m,^mswin,io ) {
	if ( defined( $ENV{'USERNAME'} ) ) {
	        $macros{'%USER%'} = $ENV{'USERNAME'};
	}
    } elsif ( defined( $ENV{'LOGNAME'} ) ) {
		$macros{'%USER%'} = $ENV{'LOGNAME'};
    }

    if ( -r $filename ) {
	logtrc(INFO, "Architecture declaration file $filename will be overwritten!" );
    }
    
    # Add header
    my $tpg = $EH{'template'}{'vhdl'}{'arch'}{'body'};
    my $et = replace_mac( $EH{'template'}{'vhdl'}{'arch'}{'head'}, \%macros);    

    my %seenthis = ();
    my $contflag = 0;
    #
    # Go through all instances and generate a architecture for each !entity!
    #TODO: or instance?
    #
    my @keys = ( $instance eq "__COMMON__" ) ? keys( %$ae ) : ( $instance );
    for my $i ( sort( @keys ) ) {
	
	if ( $i eq "W_NO_ENTITY" ) { next; };

	# Do not write architecture for leaf cells ...
	#TODO: Check
	if ( $EH{'output'}{'generate'}{'arch'} eq "noleaf" and
	    $ae->{$i}{'::treeobj'}->daughters eq "" ) {
	    next;
	}

	$contflag = 1;	
	
	my $aent = $ae->{$i}{'::entity'};

	if ( $aent =~ m,W_NO_ENTITY,io ) { next; };
	
	$macros{'%ENTYNAME%'} = $aent;
	$macros{'%ARCHNAME%'} = $aent . $EH{'postfix'}{'POSTFIX_ARCH'};
	$macros{'%CONCURS%'} = "\t-- Generated Signal Assignments\n";
	$macros{'%CONSTANTS%'} = "\t--Generated Constant Declarations\n";

	# Search for constants in our connection hash....
	for my $ii ( sort( keys( %{$hierdb{$i}{'::conn'}{'in'}} ) ) ) {
	    my $s = $conndb{$ii};
	    my $mode = $s->{'::mode'};
	    if ( $mode =~ m,^\s*C,io ) {
		my $type = $s->{'::type'};
		my $high = $s->{'::high'};
		my $low = $s->{'::low'};
		# The signal definition should be consistent here!
		my $dt = "";

		if ( defined( $high ) and $high =~ m/^\d+$/o and
		     defined( $low ) and $low =~ m/^\d+$/o ) {
			if ( $low < $high ) {
			    $dt = "($high downto $low)";
			} elsif ( $low > $high ) {
			    $dt = "($high to $low)";
			} else {
			    $dt = " -- __W_SINGLE_BIT_CONSTANT";
			}
		}
	    
		unless( exists ( $s->{'::out'}[0]{'inst'} ) ) {
		    $s->{'::out'}[0]{'inst'} = "__E_MISSING_VALUE";
		}
		$macros{'%CONSTANTS%'} .= "\t\t\tconstant " . $s->{'::name'} . " : " .
		    $s->{'::type'} . $dt . " := " . $s->{'::out'}[0]{'inst'} . ";\n";
		next;
	    }
	}

	#
	# Collect components by looking through all our daughters
	#
	$macros{'%COMPONENTS%'} = "\t-- Generated Components\n";
	$macros{'%INSTANCES%'} = "\t-- Generated Instances and Port Mappings\n";

	my %seen = ();
	my @in= ();
	my @out = ();
	#
	# Inform user about rewrite of architecture for this entity ...
	#
	if ( exists( $seenthis{$aent} ) ) {
	    logtrc( "INFO:4",  "Possibly rewriting architecture for entity $aent, instance $i!" );
	} else {
	    $seenthis{$aent} = 1;
	}
	
	my $node = $ae->{$i}{'::treeobj'};
	for my $daughter ( sort( { $a->name cmp $b->name } $node->daughters ) ) {
	    my $d_name = $daughter->name;
	    my $d_enty = $hierdb{$d_name}{'::entity'};

	    #
	    # Component declaration (?):
	    # 
	    unless( exists( $seen{$d_enty} ) ) {
		$macros{'%COMPONENTS%'} .= "\t\t\tcomponent $d_enty\n" .
			"\t\t\tgeneric (\n" . $entities{$d_enty}{'__GENERICTEXT__'} .
			"\n\t\t\t);\n" .
			"\t\t\tport (\n" . $entities{$d_enty}{'__PORTTEXT__'} .
			"\n\t\t\t);\n" .
			"\t\t\tend component;\n\t\t-- ---------\n\n";
		$seen{$d_enty} = 1;
	    }

	    #
	    # Instances
	    #
	    my( $imap, $r_in, $r_out );
	    ( $imap, $r_in, $r_out ) = gen_instmap( $d_name );
	    $macros{'%INSTANCES%'} .= $imap;
	    push( @in, @$r_in );
	    push( @out, @$r_out );
	}

	#
	# Look through current instance and extract constant declarations
	#
	# for my $const ( %{$hierdb{$i}} ) {
	#    if ( $const->{'::mode'} and $const->{'::mode'} eq "C" ) {
	#	#read value from out field, 
	#
	# extract signals from @in and @out array
	#
	my %aeport = ();
	# Uniquify
	for my $ii ( @out ) { $aeport{$ii}{'out'} = 1; };
	for my $ii ( @in )   { $aeport{$ii}{'in'} = 1; };
	my $signaltext = "\t\t\t--\n\t\t\t-- Generated Signals\n\t\t\t--\n";
	for my $ii ( sort( keys( %aeport ) ) ) {
	    my $s = $conndb{$ii};
	    my $type = $s->{'::type'};
	    my $high = $s->{'::high'};
	    my $low = $s->{'::low'};
	    # The signal definition should be consistent here!
	    my $dt = "";

	    if ( $ii =~ m/^\s*__LOGIC(0|1)_BUS__/  ) {#! not used here
		# Define signal as below and assign it to zero/one, wire port to it!
		#TODO: This works for busses. Will it do for single signal?
		#TODO: What happens to bus slices?
		$macros{'%CONCURS%'} .= "\t\t\t__LOGIC$1__ <= ( others => '$1' );\n";
	    } elsif ( $ii =~ m/^\s*__LOGIC(0|1)__/  ) {#! not used here
		# Define signal as below and assign it to zero/one, wire port to it!
		#TODO: This works for busses. Will it do for single signal?
		#TODO: What happens to bus slices?
		$macros{'%CONCURS%'} .= "\t\t\t__LOGIC$1__ <= '$1';\n";
	    } elsif ( $ii =~ m,^\s*(%HIGH|%LOW)_BUS,o ) {
		my $logicv = ( $1 eq '%HIGH' ) ? '1' : '0';
		$macros{'%CONCURS%'} .= "\t\t\t$EH{'macro'}{$ii} <= ( others => '$logicv' );\n";
	    } elsif ( $ii =~ m,^\s*(%HIGH%|%LOW%),o ) {
	    	my $logicv = ( $1 eq '%HIGH' ) ? '1' : '0';
		$macros{'%CONCURS%'} .= "\t\t\t$EH{'macro'}{$ii} <= '$logicv';\n";
	    }

	    if ( defined( $high ) and $high =~ m/^\d+$/o and
		 defined( $low ) and $low =~ m/^\d+$/o ) {
		    if ( $low < $high ) {
			$dt = "($high downto $low)";
		    } elsif ( $low > $high ) {
			$dt = "($high to $low)";
		    } else {
			$dt = " -- __W_SINGLE_BIT_BUS";
		    }
	    }
	    
	    # Add constant and generic definitions here ...
	    if ( $s->{'::mode'} =~ m,\s*(c),io ) {
		#unless( exists ( $s->{'::out'}[0]{'inst'} ) ) {
		#    $s->{'::out'}[0]{'inst'} = "__E_MISSING_VALUE";
		#}
		#$macros{'%CONSTANTS%'} .= "\t\t\tconstant " . $s->{'::name'} . " : " .
		#    $s->{'::type'} . $dt . " := " . $s->{'::out'}[0]{'inst'} . ";\n";
		next;
	    }

	    if ( $s->{'::mode'} =~ m,\s*(g),io ) {
		next;
	    }

	    $signaltext .= "\t\t\tsignal\t$ii\t: $type$dt;\n";
	}

	$signaltext .= "\t\t\t--\n\t\t\t-- End of Generated Signals\n\t\t\t--\n";
	$macros{'%SIGNALS%'} = $signaltext;
	$et .= replace_mac( $tpg, \%macros );

    }

    return unless ( $contflag ); #Print only if you found s.th. to print

    $et .=  $EH{'template'}{'vhdl'}{'enty'}{'foot'};

    $et = replace_mac( $et, \%macros );

    $et = strip_empty( $et );

    #
    # Write here
    #
    unless( open( ARCH, "> $filename" ) ) {
        logwarn( "Cannot open file $filename to write architecture declarations: $!" );
        return;
    }

    
    print( ARCH $et );

    close( ARCH ) or
	logwarn( "Cannot close file $filename: $!" );
}

sub strip_empty ($) {
    my $text = shift;

    #
    # Remove empty "generic" statments
    #
    #        -- Generics:
    #			generic (
    #		-- generated
    #
    #
    #		);
    $text =~ s,\s*--\s*Generics:\s+generic\s*\(\s+--\s+generated\s+\);,,sog;
    $text =~ s,generic\s*\(\s+--\s+generated\s+\);,,sog;

    return $text;
}
    
####################################################################
## write_configuration
## write configurarion for VHDL files
####################################################################

=head2

write_configuration () {

Write configuration into output file(s).

=cut

sub write_configuration () {

    # Set up configuration template;
    tmpl_conf();
    
    # open output file
    my %seen = ();
    my $efname = $EH{'outconf'};
    if ( $efname =~m/^CONF/o ) {
	# Write each configuration in a file of it's own
	for my $i ( sort( keys( %hierdb ) ) ) {
		# Skip it if it was seen before
		#TODO: sort by order of hierachy??

    		if ( $EH{'output'}{'generate'}{'conf'} eq "noleaf" and
		    not $hierdb{$i}{'::treeobj'}->daughters ) {
		    next;
		}

		my $e = $hierdb{$i}{'::entity'};
		unless ( exists( $seen{$e} ) ) {
		    # my %a; $a{$e} = %{$hierdb{$i}}; # Take one slice from the hierdb ...
		    $seen{$e} = 1;  #TODO ?????
		    my $filename = $e . $EH{'postfix'}{'POSTFIX_CONF'} . "-c.vhd";
		    _write_configuration( $i, $e, $filename, \%hierdb );
		}
	}
    } else {
	_write_configuration( "__COMMON__", "__COMMON__", $efname, \%hierdb );
    }

    return;

}

#
# Do the work:
#
sub _write_configuration ($$$$) {
    my $instance = shift;
    my $entity = shift;
    my $filename = shift;
    my $ae = shift;

    my %macros = %{$EH{'macro'}}; # Take predefined macro replacement set

    $macros{'%INSTNAME%'} = $instance;
    $macros{'%ARCHNAME%'} = $entity . $EH{'postfix'}{'POSTFIX_ARCH'};    
    $macros{'%CONFNAME%'} = $entity . $EH{'postfix'}{'POSTFIX_CONF'}; 
    $macros{'%VERSION%'} = $::VERSION;
    $macros{'%0%'} = $::pgm;
    $macros{'%DATE%'} = "" . localtime();
    $macros{'%USER%'} = "W_UNKNOWN_USERNAME";
    if ( $^O =~ m,^mswin,io ) {
	if ( defined( $ENV{'USERNAME'} ) ) {
	        $macros{'%USER%'} = $ENV{'USERNAME'};
	}
    } elsif ( defined( $ENV{'LOGNAME'} ) ) {
		$macros{'%USER%'} = $ENV{'LOGNAME'};
    }

    if ( -r $filename ) {
	logtrc(INFO, "Configuration definition file $filename will be overwritten!" );
    }
    
    unless( open( CONF, "> $filename" ) ) {
        logwarn( "Cannot open file $filename to write configuration definitions: $!" );
        return;
    }

    # Add header
    my $tpg = $EH{'template'}{'vhdl'}{'conf'}{'body'};
    my $et = replace_mac( $EH{'template'}{'vhdl'}{'conf'}{'head'}, \%macros);    

    my %seenthis = ();

    #
    # Go through all instances and generate a configuration for each !entity!
    #TODO: or instance?
    #
    my @keys = ( $instance eq "__COMMON__" ) ? keys( %$ae ) : ( $instance );
    for my $i ( sort( @keys ) ) {

	# Do not write configurations for leaf cells ...
	#TODO: Check
	if ( $EH{'output'}{'generate'}{'conf'} eq "noleaf" and
	    $hierdb{$i}{'::treeobj'}->daughters == 0  ) {
		next;
	}
	# Skip some internals
	if ( $i eq "W_NO_ENTITY" ) { next; };
	if ( $i eq "W_NO_CONFIG" ) { next; };
    
	my $aent = $ae->{$i}{'::entity'};

	if ( $aent eq "W_NO_ENTITY" ) { next; }
	
	$macros{'%ENTYNAME%'} = $aent;
	#TODO: $macros{'%CONFNAME%' = $aent . $EH{'postfix'}{'POSTFIX_CONF'};
	$macros{'%CONFNAME%'} = $ae->{$i}{'::config'};
	$macros{'%ARCHNAME%'} = $aent . $EH{'postfix'}{'POSTFIX_ARCH'};

	#
	# Collect components by looking through all our daughters
	#
	$macros{'%CONFIGURATION%'} = "\t-- Generated Configuration\n";

	# my %seen = ();
	my @in = ();
	my @out = ();
	#
	# Inform user about rewrite of architecture for this entity ...
	#
	if ( exists( $seenthis{$aent} ) ) {
	    logwarn( "Possibly rewriting configuration for entity $aent, instance $i!" );
	} else {
	    $seenthis{$aent} = 1;
	}
	
	my $node = $ae->{$i}{'::treeobj'};
	for my $daughter ( sort( { $a->name cmp $b->name } $node->daughters ) ) {
	    my $d_name = $daughter->name;
	    my $d_enty = $hierdb{$d_name}{'::entity'};
	    my $d_conf = $hierdb{$d_name}{'::config'};

	    #
	    # Component declaration (?):
	    # 
	    # unless( exists( $seen{$d_enty} ) ) {
		$macros{'%CONFIGURATION%'} .= "\t\t\tFOR $d_name : $d_enty\n" .
			"\t\t\t\tuse configuration work.$d_conf;\n" .
			"\t\t\tEND FOR;\n";
	    # $seen{$d_enty} = 1;
	    # }
	}
	$et .= replace_mac( $tpg, \%macros );

    }
     
    $et .=  $EH{'template'}{'vhdl'}{'conf'}{'foot'};
    $et = replace_mac( $et, \%macros );
    
    print( CONF $et );

    close( CONF ) or
	logwarn( "Cannot close file $filename: $!" );
}

1;

#!End