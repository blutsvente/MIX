###############################################################################
#  RCSId: $Id: RegViewIPXACT.pm,v 1.2 2008/05/09 14:49:10 herburger Exp $
###############################################################################
#                                  
#  Related Files :  Reg.pm
#
#  Author(s)     :  Gregor Herburger                                      
#  Email         :  Gregor.Herburger@micronas.com                          
#
#  Project       :  mix                                                 
#
#  Creation Date :  03.04.2008
#
#  Contents      :  Generate XML view of Reg objects 
#
###############################################################################
#                               Copyright
###############################################################################
#
#       Copyright (C) 2008 Micronas GmbH, Munich, Germany 
#
#     All rights reserved. Reproduction in whole or part is prohibited
#          without the written permission of the copyright owner.
#
###############################################################################
#                                History
###############################################################################
#
#  $Log: RegViewIPXACT.pm,v $
#  Revision 1.2  2008/05/09 14:49:10  herburger
#  initial release
#
#
#  
###############################################################################

package Micronas::Reg; # the class-name

#------------------------------------------------------------------------------
# Used packages
#------------------------------------------------------------------------------
#use strict;
use FindBin qw($Bin);
use lib "$Bin";
use lib "$Bin/..";
use lib "$Bin/lib";
use Data::Dumper;
use Micronas::MixUtils qw($eh %OPTVAL);
use Micronas::Reg;
use Micronas::RegDomain;
use Micronas::RegReg;
use Micronas::RegField;
use Micronas::RegViews;
use Micronas::MixUtils::RegUtils;
use XML::Writer;
use IO::File;



#------------------------------------------------------------------------------
# Methods
# First parameter passed to method is implicit and is the object reference 
# ($this) if the method # is called in <object> -> <method>() fashion.
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# view: IP-XACT
# Main entry function of this module;
# input: view-name, list ref. to domain names for which output is generated; if empty, 
# will consider ALL register space domains in the Reg object;
# output: 0 in case of non-recoverable error, 1 otherwise
sub _gen_view_ipxact {
    my $this = shift;
    my ($view_name, $lref_domains) = @_;
    
      
    
    # extend class data with data structure needed for code generation
    $this->global('ldomains'		=>	[]);	
    
    
  
    
 
   
   
    
    # check over which domains we want to iterate
    if (scalar (@$lref_domains)) {
	#@$lref_domains not empty
	foreach my $o_domain (@$lref_domains) {
	    push @{$this->global->{'ldomains'}}, $this->find_domain_by_name_first($o_domain);
	};
    } else {
	#No Domains specified -> use all
	foreach my $href (@{$this->domains}) {
	    push @{$this->global->{'ldomains'}}, $href->{'domain'};
	};
    };

    #$this->display();

    #print Dumper($eh);

    #write ip-xact to file
    $this->_write_ipxact2file();
    
}



##################################
# _write_ipxact2file
# 
#################################
sub _write_ipxact2file{
    my $this=shift;

    my($o_domain, $o_register, $field, $o_field, $parameter);
    my($nsspirit,$nsschema, $schemalocation)=($eh->get('xml.NS_URI.spirit'),$eh->get('xml.NS_URI.schema'),$eh->get('xml.NS_URI.schemalocation'));
    my $doc;
   
    ##Start Writing to File
    my $filename=join("_",$eh->get('xml.file_prefix'),map{$_->{'name'}}(@{$this->global->{'ldomains'}})).".".$eh->get('xml.file_suffix');

    if (-e $filename){
	#File exists
	if (!($doc = new IO::File(">".$filename))){
	    _error("could not open file \'$filename\' for writing");
	    return 0;
	}else {
	    _info("writing to file \'$filename\'")
	}
    }else{
	#make new file
	if (!($doc = new IO::File(">".$filename))){
	    _error("could not create file \'$filename\' for writing");
	    return 0;
	}else {
	    _info("creating file \'$filename\'")
	}
    }

    
    my $writer = new XML::Writer(OUTPUT => $doc,NEWLINES =>0, NAMESPACES =>1, DATA_MODE => 1, DATA_INDENT =>4, ,PREFIX_MAP => {$nsspirit=>"spirit", $nsschema=>"xsi"});
    _info("Start Writing XML-File");

    #XML-Declaration
    $writer->xmlDecl($eh->get('xml.characterencoding'));

    $writer->comment("IP-XACT 1.4 File. Automatically generated by MIX");

    #TopLevel
    $writer->startTag([$nsspirit, "component"],[$nsschema,"schemaLocation"]=>"$schemalocation");
    

    #versionIdentifier

    $writer->dataElement([$nsspirit, "vendor"],$eh->get('xml.versionedIdentifier.vendor'));

    $writer->dataElement([$nsspirit, "library"],$eh->get('xml.versionedIdentifier.library'));

    $writer->dataElement([$nsspirit, "name"],$eh->get('xml.versionedIdentifier.name'));

    $writer->dataElement([$nsspirit, "version"],$eh->get('xml.versionedIdentifier.version'));

      
    
    $writer->startTag([$nsspirit, "memoryMaps"]);
    

    # Each Domain is one Memory Map with one Addressblock
    foreach $o_domain (@{$this->global->{'ldomains'}}){
	_info("generating IP-XACT code for domain ",$o_domain->name);
	$writer->startTag([$nsspirit,"memoryMap"]);
	
	# Name of the Memory Map is the name of the domain
	$writer->dataElement([$nsspirit, "name"],$o_domain->{'name'});
	
	$writer->startTag([$nsspirit, "addressBlock"]);

	#Name of the Addressblock is the name of the domain
	$writer->dataElement([$nsspirit, "name"],$o_domain->{'name'});
	
	# Print the Definition into displayName if definition exists
	$writer->dataElement([$nsspirit, "displayName"],$o_domain->{'definition'}) if ($o_domain->{'definition'});

	#baseaddress of the block
	my $baseaddr=$this->get_domain_baseaddr($o_domain->{'name'});
	$writer->dataElement([$nsspirit, "baseAddress"],$baseaddr);

	#range is the number of addressable units = 2^(Address Width)
	my $range=2**($eh->get("reg_shell.addrwidth"));
	$writer->dataElement([$nsspirit, "range"],$range);

	#bit width of a row
	$writer->dataElement([$nsspirit, "width"],$eh->get("reg_shell.regwidth"));

	$writer->dataElement([$nsspirit, "usage"],"register");

	#iterarte through all register
	foreach $o_register (@{$o_domain->{'regs'}}){
	    
	    $writer->startTag([$nsspirit, "register"]);

	    $writer->dataElement([$nsspirit, "name"],$o_register->{'name'});

	    # Print the Definition into displayName if definition exists
	    $writer->dataElement([$nsspirit, "displayName"],$o_register->{'definition'}) if ($o_register->{'definition'});

	    $writer->dataElement([$nsspirit, "addressOffset"], $o_domain->get_reg_address($o_register));
	    
	    $writer->dataElement([$nsspirit, "size"], $o_register->{'attribs'}->{'size'});

	    #Direction of the register derived from field directions
	    my $registerdirection=$this->get_register_direction_from_fields($o_register);
	    if ($registerdirection){#Print only if exists
		$writer->dataElement([$nsspirit, "access"],$eh->get('xml.access.'.$registerdirection));
	    }
	    	    
	    #Reset Value of Register, derived from fields
	    $writer->startTag([$nsspirit, "reset"]);
	    $writer->dataElement([$nsspirit, "value"],$o_register->get_reg_init());
	    $writer->dataElement([$nsspirit, "mask"],$o_register->{'attribs'}->{'usedbits'});
	    $writer->endTag([$nsspirit, "reset"]);

	    #iterate throug all fields
	    foreach $field (@{$o_register->{'fields'}}){
		$o_field=$field->{'field'};
		
		$writer->startTag([$nsspirit, "field"]);

		$writer->dataElement([$nsspirit, "name"],$o_field->{'name'});
		
		# Print the Definition into displayName if definition exists
		$writer->dataElement([$nsspirit, "displayName"],$o_field->{'definition'}) if ($o_field->{'definition'});


		my $fielddescription = $o_field->{'attribs'}->{'comment'};
		######Caveat: fielddescription contains iso-8859-1 characters, if utf-8 is wanted, it has to be converted
		$writer->dataElement([$nsspirit, "description"],$fielddescription);

		$writer->dataElement([$nsspirit, "bitOffset"], $field->{'pos'});
		$writer->dataElement([$nsspirit, "bitWidth"], $o_field->{'attribs'}->{'size'});

		my $access=$eh->get('xml.access.'.$o_field->{'attribs'}->{'dir'});
		$writer->dataElement([$nsspirit, "access"], $access);

		#Parameters Section
		$writer->startTag([$nsspirit, "parameters"]);

		foreach $parameter (keys %{$o_field->{'attribs'}}){
		    #fields to Skip
		    next if(grep($parameter eq $_,@{$eh->get('xml.field_skipelements')}));

		    
		    if (defined $eh->get('xml.prettynames.'.$parameter)){
			$parametername=$eh->get('xml.prettynames.'.$parameter);
		    }else{
			$parametername=$parameter;
		    }

		    #Create for each Value in the field object an Parameter field
		    $writer->startTag([$nsspirit, "parameter"]);
		    $writer->dataElement([$nsspirit, "name"],$parametername);
		    $writer->dataElement([$nsspirit, "value"],$o_field->{'attribs'}->{$parameter});
		    $writer->endTag([$nsspirit, "parameter"]);

		}

		$writer->endTag([$nsspirit, "parameters"]);

		$writer->endTag([$nsspirit, "field"]);
	    }
	    
	    #Parameters for Register element
	    $writer->startTag([$nsspirit, "parameters"]);
	    
	    $writer->startTag([$nsspirit, "parameter"]);
	    $writer->dataElement([$nsspirit, "name"],"clone");
	    $writer->dataElement([$nsspirit, "value"],$o_register->{'attribs'}->{'clone'});
	    $writer->endTag([$nsspirit, "parameter"]);
	    
	    $writer->endTag([$nsspirit, "parameters"]);
			    
	    $writer->endTag([$nsspirit, "register"]);
	}

	
	$writer->endTag([$nsspirit, "addressBlock"]);

	$writer->dataElement([$nsspirit, "addressUnitBits"],$eh->get('reg_shell.datawidth'));

	$writer->endTag([$nsspirit, "memoryMap"]);
    }
    
    #EOF
    $writer->endTag([$nsspirit, "memoryMaps"]);

    $writer->endTag([$nsspirit, "component"]);
    $writer->end();#End Document, for error detection
    $doc->close();#Close File Handle
    
}
1;
